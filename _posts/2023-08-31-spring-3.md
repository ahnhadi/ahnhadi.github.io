---
title: "[Spring] 영속성 컨텍스트"
excerpt: "영속성 컨텍스트란?"

categories: # 카테고리 설정
  - Spring
tags: # 포스트 태그
  - [Spring, SpringBoot, 영속성 컨텍스트, JPA]

permalink: /spring/persistence-context/ # 포스트 URL

toc: true # 우측에 본문 목차 네비게이션 생성
toc_sticky: true # 본문 목차 네비게이션 고정 여부

date: 2023-08-31 # 작성 날짜
last_modified_at: 2023-08-31 # 최종 수정 날짜
---

# 영속성 컨텍스트란?

<mark>영속성 컨텍스트는 JPA의 중요한 특징 중 하나, 엔티티를 관리하는 가상의 공간</mark>

## 1차 캐시
- <mark>영속성 컨텍스트는 내부에 1차 캐시를 가지고 있음</mark>
- 캐시의 키는 엔티티의 `@Id` 애너테이션이 달린 기본기 역할을 하는 **식별자**이며 *값은 엔티티*
- 엔티티 조회시 1차캐시에서 데이터를 조회하고 값이 있으면 **반환**
- *값이 없을 경우* 데이터베이스에서 조회해 1차 캐시에 저장한 다음 반환  
> 캐시된 데이터를 조회할 때에는 데이터베이스를 거치지 않아도 되므로 **매우 빠르게 데이터를 조회**할 수 있음


## 쓰기 지연(transactional write-behind)
- 트랜잭션을 커밋하기 전까지는 데이터베이스에 실제로 질의문을 보내지 **않고** 쿼리를 모았다가  
  트랜잭션을 커밋하면 모았던 쿼리를 *한번에 실행*하는 것을 의미
> 적당한 묶음으로 쿼리를 요청할 수 있어 데이터베이스 시스템의 부담을 줄일 수 있음

## 변경 감지
- 트랜잭션을 커밋하면 1차 캐시에 저장되어 있는 엔티티의 값과 현재 엔티티의 값을 비교해서 변경된 값이 있다면  
  변경사항을 감지해 변경된 값을 *데이터베이스에 자동으로 반영*
> 적당한 묶음으로 쿼리 요청할 수 있어 데이터베이스 시스템의 부담을 줄일 수 있음

## 지연 로딩(lazy loading)
- 쿼리로 요청한 데이터를 애플리케이션에 바로 로딩하는 것이 아니라 **필요할 때 쿼리를 날려 데이터를 조회**


---
# 엔티티의 상태
> 엔티티는 4가지의 상태를 가짐  
  - 분리(detached) 상태 : 영속성 컨텍스트가 관리하고 있지 않음
  - 관리(managed) 상태 : 영속성 컨텍스트가 관리함
  - 비영속(transient) 상태 : 영속성 컨텍스트와 전혀 관계가 없음
  - 삭제된(removed) 상태 : 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제

## 엔티티 상태 변경
```java
public class EntityManagerTest {
    @Autowired
    Entitymanager em;

    public void example() {
        // 1. 엔티티 매니저가 엔티티를 관리하지 않는 상태(비영속 상태)
        Member member = new Member(1L, "홍길동");

        // 2. 관리 상태
        em.persist(member);
        // 3. 엔티티 객체가 분리된 상태
        em.detach(member);
        // 4. 삭제 상태
        em.remove(member);
    }
}
```